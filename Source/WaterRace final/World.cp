/*****************************************************************************
 * Copyright (c) 1998-2001, French Touch, SARL
 * http://www.french-touch.net
 * info@french-touch.net
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
 *****************************************************************************/


#include				<fp.h>#include				"WaterRace.h"#include				"Game.h"#include				"Preferences.h"#include				"Data Files.h"#include				"Drivers.h"#include				"Network Engine.h"#include				"Infinity Rendering.h"#include				"Clock.h"#include				"Vector.h"#include				"Infinity Audio Engine.h"#include				"Infinity Post FX.h"#include				"Textures.h"#include				"Quaternion.h"#include				"MetaFile Data Tags.h"#include				"Cinematic Utils.h"#include				"Model Animation Utils.h"#include				"MetaFile Utils.h"#include				"Terrain Utils.h"#include				"Shape Utils.h"#include				"Object Utils.h"//CONSTANTES:#define					kTurboTextureID			200#define					kJokerTextureID			201#define					kWakeTextureID			250#define					kMinCheckPoints			3#define					kTerrainFrontierWidth	10.0//VARIABLES:StatePtr				worldState;CameraState				worldCamera;ModelAnimationPtr		flyThroughCameraAnimation;Terrain					theTerrain;ShapePtr				skyShape = nil;RaceDescriptionPtr		theRace;long					modelCount = 0;ExtendedModel			modelList[kMaxModels];TextureMemory			videoMemory;TQATexture				*turboTexture = nil,						*jokerTexture = nil,						*wakeTexture = nil;Boolean					videoFX;long					shipCount = 0;ExtendedShip			shipList[kMaxPlayers];ShapePtr				arrowShape;#if __RENDER_CHECK_POINTS__ShapePtr				checkPoint_left,						checkPoint_middle,						checkPoint_right;ShapePtr				start_left,						start_middle,						start_right;#endiffloat					terrain_MinX,						terrain_MaxX,						terrain_MinZ,						terrain_MaxZ;float					border_MinX,						border_MaxX,						border_MinZ,						border_MaxZ;CollisionTilePtr		collisionMap = nil;long					collisionMapWidth,						collisionMapHeight;//ROUTINES:static void CollisionBox_PreProcess(CollisionBoxPtr box){	box->halfSize_x = Vector_Length(box->xVector) / 2.0;	box->halfSize_y = Vector_Length(box->yVector) / 2.0;	box->halfSize_z = Vector_Length(box->zVector) / 2.0;		Vector_Normalize(&box->xVector, &box->matrix.x);	Vector_Normalize(&box->yVector, &box->matrix.y);	Vector_Normalize(&box->zVector, &box->matrix.z);	box->matrix.w = box->center;		box->corners[0].x = box->center.x - box->xVector.x / 2.0 - box->yVector.x / 2.0 - box->zVector.x / 2.0;	box->corners[0].y = box->center.y - box->xVector.y / 2.0 - box->yVector.y / 2.0 - box->zVector.y / 2.0;	box->corners[0].z = box->center.z - box->xVector.z / 2.0 - box->yVector.z / 2.0 - box->zVector.z / 2.0;		box->corners[1].x = box->center.x + box->xVector.x / 2.0 - box->yVector.x / 2.0 - box->zVector.x / 2.0;	box->corners[1].y = box->center.y + box->xVector.y / 2.0 - box->yVector.y / 2.0 - box->zVector.y / 2.0;	box->corners[1].z = box->center.z + box->xVector.z / 2.0 - box->yVector.z / 2.0 - box->zVector.z / 2.0;		box->corners[2].x = box->center.x + box->xVector.x / 2.0 - box->yVector.x / 2.0 + box->zVector.x / 2.0;	box->corners[2].y = box->center.y + box->xVector.y / 2.0 - box->yVector.y / 2.0 + box->zVector.y / 2.0;	box->corners[2].z = box->center.z + box->xVector.z / 2.0 - box->yVector.z / 2.0 + box->zVector.z / 2.0;		box->corners[3].x = box->center.x - box->xVector.x / 2.0 - box->yVector.x / 2.0 + box->zVector.x / 2.0;	box->corners[3].y = box->center.y - box->xVector.y / 2.0 - box->yVector.y / 2.0 + box->zVector.y / 2.0;	box->corners[3].z = box->center.z - box->xVector.z / 2.0 - box->yVector.z / 2.0 + box->zVector.z / 2.0;		box->corners[4].x = box->center.x - box->xVector.x / 2.0 + box->yVector.x / 2.0 - box->zVector.x / 2.0;	box->corners[4].y = box->center.y - box->xVector.y / 2.0 + box->yVector.y / 2.0 - box->zVector.y / 2.0;	box->corners[4].z = box->center.z - box->xVector.z / 2.0 + box->yVector.z / 2.0 - box->zVector.z / 2.0;		box->corners[5].x = box->center.x + box->xVector.x / 2.0 + box->yVector.x / 2.0 - box->zVector.x / 2.0;	box->corners[5].y = box->center.y + box->xVector.y / 2.0 + box->yVector.y / 2.0 - box->zVector.y / 2.0;	box->corners[5].z = box->center.z + box->xVector.z / 2.0 + box->yVector.z / 2.0 - box->zVector.z / 2.0;		box->corners[6].x = box->center.x + box->xVector.x / 2.0 + box->yVector.x / 2.0 + box->zVector.x / 2.0;	box->corners[6].y = box->center.y + box->xVector.y / 2.0 + box->yVector.y / 2.0 + box->zVector.y / 2.0;	box->corners[6].z = box->center.z + box->xVector.z / 2.0 + box->yVector.z / 2.0 + box->zVector.z / 2.0;		box->corners[7].x = box->center.x - box->xVector.x / 2.0 + box->yVector.x / 2.0 + box->zVector.x / 2.0;	box->corners[7].y = box->center.y - box->xVector.y / 2.0 + box->yVector.y / 2.0 + box->zVector.y / 2.0;	box->corners[7].z = box->center.z - box->xVector.z / 2.0 + box->yVector.z / 2.0 + box->zVector.z / 2.0;}static void MegaObject_CollisionAware(MegaObjectPtr mega){	VectorPtr				temp;	CollisionBoxPtr			box;	long					i;		if(mega->boxCount == 0) {		temp = mega->object.boundingBox;		box = &mega->boxList[0];						Vector_Subtract(&temp[1], &temp[0], &box->xVector);		Vector_Subtract(&temp[4], &temp[0], &box->yVector);		Vector_Subtract(&temp[3], &temp[0], &box->zVector);		box->center.x = temp[0].x + box->xVector.x / 2.0 + box->yVector.x / 2.0 + box->zVector.x / 2.0;		box->center.y = temp[0].y + box->xVector.y / 2.0 + box->yVector.y / 2.0 + box->zVector.y / 2.0;		box->center.z = temp[0].z + box->xVector.z / 2.0 + box->yVector.z / 2.0 + box->zVector.z / 2.0;				mega->boxCount = 1;	}		for(i = 0; i < mega->boxCount; ++i)	CollisionBox_PreProcess(&mega->boxList[i]);}static long Get_NextCheckPoint(RaceTrackPtr theTrack, long current){	do {		//Get next door		++current;		if(current >= theTrack->checkCount)		current = 0;				//Is it a check point?		if(theTrack->checkList[current].flags & kCheckFlag_IsCheckPoint)		return current;	} while(1);}static RaceDescriptionPtr World_BuildRaceDescription(RaceTrackPtr theTrack){	RaceDescriptionPtr		race;	long					i;	CheckPtr				check;	RaceDoorPtr				door, prev, next;	long					nextCheckPoint;	Vector					d1,							d2;								//Allocate memory	race = (RaceDescriptionPtr) NewPtr(sizeof(RaceDescription) + theTrack->checkCount * sizeof(RaceDoor));	if(race == nil)	return nil;		//Patch first check	theTrack->checkList[0].flags |= kCheckFlag_IsCheckPoint;		//Find next check point	nextCheckPoint = Get_NextCheckPoint(theTrack, 0);		//Build race#if __BOT_ONLY__	race->lapNumber = 20;#elif __ONE_LAP__	race->lapNumber = 1;#else	race->lapNumber = theTrack->lapNumber;#endif	race->doorCount = theTrack->checkCount;	check = theTrack->checkList;	door = race->doorList;	for(i = 0; i < theTrack->checkCount; ++i, ++check, ++door) {		if(check->flags & kCheckFlag_IsCheckPoint)		door->isCheckPoint = true;		else		door->isCheckPoint = false;				if(i == nextCheckPoint)		nextCheckPoint = Get_NextCheckPoint(theTrack, nextCheckPoint);		door->nextCheckPoint = nextCheckPoint;				door->rightMark = check->rightMark;		door->leftMark = check->leftMark;		door->middle.x = (check->leftMark.x + check->rightMark.x) / 2.0;		door->middle.y = (check->leftMark.y + check->rightMark.y) / 2.0;		door->middle.z = (check->leftMark.z + check->rightMark.z) / 2.0;				door->squareDoorWidth = (check->rightMark.x - check->leftMark.x) * (check->rightMark.x - check->leftMark.x) 			+ (check->rightMark.z - check->leftMark.z) * (check->rightMark.z - check->leftMark.z);		door->doorWidth = sqrt(door->squareDoorWidth);				door->doorMatrix.x.x = check->leftMark.x - check->rightMark.x;		door->doorMatrix.x.y = 0.0;		door->doorMatrix.x.z = check->leftMark.z - check->rightMark.z;		Vector_Normalize(&door->doorMatrix.x, &door->doorMatrix.x);		door->doorMatrix.y.x = 0.0;		door->doorMatrix.y.y = 1.0;		door->doorMatrix.y.z = 0.0;		Vector_CrossProduct(&door->doorMatrix.x, &door->doorMatrix.y, &door->doorMatrix.z);		door->doorMatrix.w = check->rightMark;				Matrix_Negate(&door->doorMatrix, &door->negatedDoorMatrix);	}		for(i = 0; i < race->doorCount; ++i) {		door = &race->doorList[i];				if(i > 0)		prev = &race->doorList[i - 1];		else		prev = &race->doorList[race->doorCount - 1];				if(i < race->doorCount - 1)		next = &race->doorList[i + 1];		else		next = &race->doorList[0];				d1.x = door->middle.x - prev->middle.x;		d1.y = 0.0;		d1.z = door->middle.z - prev->middle.z;		Vector_Normalize(&d1, &d1);		d2.x = next->middle.x - door->middle.x;		d2.y = 0.0;		d2.z = next->middle.z - door->middle.z;		Vector_Normalize(&d2, &d2);		door->doorAngle = Vector_DotProduct(&d1, &d2);				if((d1.z * d2.x - d1.x * d2.z) < 0.0) //We are turning right		door->turningRight = true;		else		door->turningRight = false;				door->distanceToNextDoor = Vector_Distance(next->middle, door->middle);	}		race->maxDoorsBetweenCheckPoints = 0;	i = 0;	do {		nextCheckPoint = Get_NextCheckPoint(theTrack, i);		if(nextCheckPoint - i > race->maxDoorsBetweenCheckPoints)		race->maxDoorsBetweenCheckPoints = nextCheckPoint - i;				i = nextCheckPoint;	} while(nextCheckPoint != 0);		return race;}static long GetTrackCPNumber(RaceTrackPtr theTrack){	long			count = 0;	long			i;		for(i = 0; i < theTrack->checkCount; ++i)	if(theTrack->checkList[i].flags & kCheckFlag_IsCheckPoint)	++count;	return count;}static OSErr Terrain_Load(FSSpec* theFile, StatePtr state, long level, OSType flyThroughID){	OSErr						theError;	long						i;	MetaFile_ReferencePtr		reference;	long						textureCount = 0;	CompressedTexturePtr		textureStorageList[kMaxTextures];	long						modelTextureCount = 0;	CompressedTexturePtr		modelTextureStorageList[kMaxTextures];	OSType						requestedTrackID;	RaceTrackPtr				theTrack = nil;		//Open MetaFile	theError = MetaFile_Read_OpenFile(theFile, &reference);	if(theError)	return theError;		//Does this file contains any terrain?	i = MetaFile_CountTags(reference, kTag_Terrain);	if(i != 1)	return kError_NoTerrainTag;		//Load terrain	theError = MetaFile_Read_Terrain(reference, &theTerrain, kMetaFile_SkipNone);	if(theError)	return theError;		//Load terrain textures	theError = MetaFile_Read_TextureList(reference, textureStorageList, &textureCount, kFakeTag_TerrainTextureList);	if(theError)	return theError;		//Load models	modelCount = MetaFile_CountTags(reference, kTag_MegaObject);	for(i = 0; i < modelCount; ++i) {		theError = MetaFile_Read_MegaObject_ByIndex(reference, &modelList[i].megaObject, i + 1, kMetaFile_SkipNone);		if(theError)		return theError;	}		//Load model textures	theError = MetaFile_Read_TextureList(reference, modelTextureStorageList, &modelTextureCount, kFakeTag_ModelTextureList);	if(theError)	return theError;		//Close MetaFile	theError = MetaFile_Read_CloseFile(reference);	if(theError)	return theError;		//Find the race track	if(gameConfig.gameMode != kGameMode_Demo) {		//Find race track ID		if(level == kDifficulty_Hard)		requestedTrackID = kTrackID_Hard;		else if(level == kDifficulty_Medium)		requestedTrackID = kTrackID_Medium;		else		requestedTrackID = kTrackID_Easy;				//Find the track		for(i = 0; i < theTerrain.trackCount; ++i)		if(theTerrain.trackList[i]->id == requestedTrackID)		theTrack = theTerrain.trackList[i];#if __DEFAULT_TRACK__		if((theTrack == nil) && (theTerrain.trackCount))		theTrack = theTerrain.trackList[0];#endif		if((theTrack == nil) || (GetTrackCPNumber(theTrack) < kMinCheckPoints)) {			Terrain_ReleaseData(&theTerrain);			return kError_TrackNotFound;		}				//Build the race description		theRace = World_BuildRaceDescription(theTrack);		if(theRace == nil) {			Terrain_ReleaseData(&theTerrain);			return kError_TrackNotFound;		}	}		//Check for the fly-through	flyThroughCameraAnimation = nil;	if(flyThroughID != kNoFlyThrough) {		for(i = 0; i < theTerrain.animCount; ++i) {			if((theTerrain.animList[i]->modelID == kFlyThroughID) && (theTerrain.animList[i]->flyID == flyThroughID))			flyThroughCameraAnimation = theTerrain.animList[i];		}		if(flyThroughCameraAnimation == nil) {			Terrain_ReleaseData(&theTerrain);			return kError_FlyThroughNotFound;		}	}		//Load terrain textures into VRAM	VRAM_Clear(&videoMemory, state->engine);	theError = VRAM_LoadTextureList(&videoMemory, textureStorageList, textureCount, thePrefs.textureFlags);	for(i = 0; i < textureCount; ++i)	Texture_Dispose(textureStorageList[i]);	if(theError) {		VRAM_Purge(&videoMemory);		for(i = 0; i < modelTextureCount; ++i)		Texture_Dispose(modelTextureStorageList[i]);		return theError;	}	theError = VRAM_LoadTextureList(&videoMemory, modelTextureStorageList, modelTextureCount, thePrefs.textureFlags);	for(i = 0; i < modelTextureCount; ++i)	Texture_Dispose(modelTextureStorageList[i]);	if(theError) {		VRAM_Purge(&videoMemory);		return theError;	}		//Prepare terrain for rendering	switch(level) {				case kDifficulty_Easy:		Terrain_Resolve(&theTerrain, &videoMemory, kVisible_Easy, flyThroughID);		break;				case kDifficulty_Medium:		Terrain_Resolve(&theTerrain, &videoMemory, kVisible_Medium, flyThroughID);		break;				case kDifficulty_Hard:		Terrain_Resolve(&theTerrain, &videoMemory, kVisible_Hard, flyThroughID);		break;			}		//Find the fly-through	if(flyThroughID != kNoFlyThrough) {		for(i = 0; i < theTerrain.animCount; ++i) {			if((theTerrain.animList[i]->modelID == kFlyThroughID) && (theTerrain.animList[i]->flyID == flyThroughID))			flyThroughCameraAnimation = theTerrain.animList[i];		}	}		//Prepare models for rendering	for(i = 0; i < modelCount; ++i)	MegaObject_Resolve(&modelList[i].megaObject, &videoMemory);		//Prepare model for collision dectection	for(i = 0; i < modelCount; ++i)	MegaObject_CollisionAware(&modelList[i].megaObject);		//Create sky	skyShape = Shape_NewSky(theTerrain.skyRadius);	if(skyShape == nil)	return MemError();	Sky_MapSkyTexture(skyShape, &theTerrain);		//Resolve sky texture	for(i = 0; i < videoMemory.textureCount; ++i)	if(videoMemory.nameList[i] == kTextureID_Sky)	skyShape->texturePtr = videoMemory.textureList[i];		return noErr;}static void Terrain_Dispose(){	long				i;		VRAM_Purge(&videoMemory);	Terrain_ReleaseData(&theTerrain);		for(i = 0; i < modelCount; ++i)	MegaObject_ReleaseData(&modelList[i].megaObject);	modelCount = 0;		Shape_Dispose(skyShape);		if(theRace != nil)	DisposePtr((Ptr) theRace);}static OSErr World_BuildCollisionMap(TerrainPtr terrain){	long				i,						j,						x,						z;	ObjectPtr			object;	CollisionTilePtr	tile;	float				minX,						maxX,						minZ,						maxZ;	ModelReferencePtr	reference;	Vector				center;	float				radius;						//Compute CM size	collisionMapWidth = (terrain_MaxX - terrain_MinX) / kCollisionMapResolution + 1;	collisionMapHeight = (terrain_MaxZ - terrain_MinZ) / kCollisionMapResolution + 1;		//Allocate memory	collisionMap = (CollisionTilePtr) NewPtr(collisionMapWidth * collisionMapHeight * sizeof(CollisionTile));	if(collisionMap == nil)	return MemError();		//Reset tiles	for(i = 0; i < collisionMapWidth * collisionMapHeight; ++i)	collisionMap[i].referenceCount = 0;		//Scan tiles	for(z = 0; z < collisionMapHeight; ++z)	for(x = 0; x < collisionMapWidth; ++x) {		//Setup tile		tile = &collisionMap[z * collisionMapWidth + x];		minX = terrain_MinX + x * kCollisionMapResolution - kCollisionMapTolerance;		maxX = terrain_MinX + (x + 1) * kCollisionMapResolution + kCollisionMapTolerance;		minZ = terrain_MinZ + z * kCollisionMapResolution - kCollisionMapTolerance;		maxZ = terrain_MinZ + (z + 1) * kCollisionMapResolution + kCollisionMapTolerance;				//Scan terrain references		for(i = 0; i < terrain->meshCount; ++i)		for(j = 0; j < terrain->meshList[i]->referenceCount; ++j) {			//Extract reference			reference = &terrain->meshList[i]->referenceList[j];			object = (ObjectPtr) reference->id;						if(!(reference->flags & kRefFlag_CollisionDetection))			continue;						Matrix_TransformVector(&reference->pos, &object->sphereCenter, &center);			radius = object->sphereRadius * reference->scale;						//Check if inside tile			if((center.x + radius > minX) && (center.x - radius < maxX) && (center.z + radius > minZ) && (center.z - radius < maxZ)) {				if(tile->referenceCount < kMaxReferences) {					tile->referenceList[tile->referenceCount] = reference;					++tile->referenceCount;				}				else				return kError_MaxItems;			}		}				//Scan sea references		for(i = 0; i < terrain->seaCount; ++i)		for(j = 0; j < terrain->seaList[i]->referenceCount; ++j) {			//Extract reference			reference = &terrain->seaList[i]->referenceList[j];			object = (ObjectPtr) reference->id;						if(!(reference->flags & kRefFlag_CollisionDetection))			continue;						Matrix_TransformVector(&reference->pos, &object->sphereCenter, &center);			radius = object->sphereRadius * reference->scale;						//Check if inside tile			if((center.x + radius > minX) && (center.x - radius < maxX) && (center.z + radius > minZ) && (center.z - radius < maxZ)) {				if(tile->referenceCount < kMaxReferences) {					tile->referenceList[tile->referenceCount] = reference;					++tile->referenceCount;				}				else				return kError_MaxItems;			}		}	}		return noErr;}OSErr World_Load(StatePtr state, FSSpec* terrainFile, long level, OSType flyThroughID){	OSErr				theError;	long				i;		//Load terrain	theError = Terrain_Load(terrainFile, state, level, flyThroughID);	if(theError) {		//Terrain_Dispose();		InfinityRendering_DisposeContext(state);		return theError;	}	Infinity_SetTerrainState(state, &theTerrain);		UseResFile(mainResFileID);	#if __RENDER_CHECK_POINTS__	//Load checkpoints shapes	theError = Shape_LoadFromResource(&start_left, 129);	if(theError)	return theError;	theError = Shape_LoadFromResource(&start_middle, 130);	if(theError)	return theError;	theError = Shape_LoadFromResource(&start_right, 131);	if(theError)	return theError;	theError = Shape_LoadFromResource(&checkPoint_left, 132);	if(theError)	return theError;	theError = Shape_LoadFromResource(&checkPoint_middle, 133);	if(theError)	return theError;	theError = Shape_LoadFromResource(&checkPoint_right, 134);	if(theError)	return theError;		//Resolve rendering	Shape_ResolveRendering(start_left);	Shape_ResolveRendering(start_middle);	Shape_ResolveRendering(start_right);	Shape_ResolveRendering(checkPoint_left);	Shape_ResolveRendering(checkPoint_middle);	Shape_ResolveRendering(checkPoint_right);#endif		//Load required FX	if((state->viewWidth > 832) && !(thePrefs.engineFlags & kPref_EngineFlagLowResolution))	theError = PostFX_Text_Init(state, thePrefs.textureFlags, kTextSize_Big);	else	theError = PostFX_Text_Init(state, thePrefs.textureFlags, kTextSize_Small);	if(theError) {		Terrain_Dispose();		InfinityRendering_DisposeContext(state);		return theError;	}	theError = Texture_NewARGB32TextureFromPictResource(state->engine, &turboTexture, kTurboTextureID, thePrefs.textureFlags | kTextureFlag_LowQuality);	if(theError) {		Terrain_Dispose();		InfinityRendering_DisposeContext(state);		return theError;	}	theError = Texture_NewARGB32TextureFromPictResource(state->engine, &jokerTexture, kJokerTextureID, thePrefs.textureFlags | kTextureFlag_LowQuality);	if(theError) {		Terrain_Dispose();		InfinityRendering_DisposeContext(state);		return theError;	}	if(thePrefs.engineFlags & kPref_EngineFlagVideoFX) {		if(theTerrain.skyFlags & kSkyFlag_RenderRain)		theError = PostFX_Rain_Init(state, thePrefs.textureFlags);		if((theError == noErr) && (theTerrain.skyFlags & kSkyFlag_RenderSnow))		theError = PostFX_Snow_Init(state, thePrefs.textureFlags);		if((theError == noErr) && (theTerrain.skyFlags & kSkyFlag_RenderMoon))		theError = PostFX_Moon_Init(state, thePrefs.textureFlags);		if((theError == noErr) && (theTerrain.skyFlags & kSkyFlag_RenderLF))		theError = PostFX_LensFlare_Init(state, thePrefs.textureFlags);				if(theError == noErr)		theError = Texture_NewARGB32TextureFromPictResource(state->engine, &wakeTexture, kWakeTextureID, thePrefs.textureFlags);				if(theError) {			Terrain_Dispose();			InfinityRendering_DisposeContext(state);			return theError;		}	}	else	theTerrain.flags &= ~kFlag_Colorize; //Disable colorize to speed up World_UpdateSea		//Compute terrain width & length	terrain_MinX = kHugeDistance;	terrain_MaxX = -kHugeDistance;	terrain_MinZ = kHugeDistance;	terrain_MaxZ = -kHugeDistance;	for(i = 0; i < theTerrain.meshCount; ++i) {		if(theTerrain.meshList[i]->boundingBox[0].x < terrain_MinX)		terrain_MinX = theTerrain.meshList[i]->boundingBox[0].x;		if(theTerrain.meshList[i]->boundingBox[1].x > terrain_MaxX)		terrain_MaxX = theTerrain.meshList[i]->boundingBox[1].x;		if(theTerrain.meshList[i]->boundingBox[0].z < terrain_MinZ)		terrain_MinZ = theTerrain.meshList[i]->boundingBox[0].z;		if(theTerrain.meshList[i]->boundingBox[2].z > terrain_MaxZ)		terrain_MaxZ = theTerrain.meshList[i]->boundingBox[2].z;	}	for(i = 0; i < theTerrain.seaCount; ++i) {		if(theTerrain.seaList[i]->boundingBox[0].x < terrain_MinX)		terrain_MinX = theTerrain.seaList[i]->boundingBox[0].x;		if(theTerrain.seaList[i]->boundingBox[1].x > terrain_MaxX)		terrain_MaxX = theTerrain.seaList[i]->boundingBox[1].x;		if(theTerrain.seaList[i]->boundingBox[0].z < terrain_MinZ)		terrain_MinZ = theTerrain.seaList[i]->boundingBox[0].z;		if(theTerrain.seaList[i]->boundingBox[2].z > terrain_MaxZ)		terrain_MaxZ = theTerrain.seaList[i]->boundingBox[2].z;	}		//Compute terrain frontieres	border_MinX = kHugeDistance;	border_MaxX = -kHugeDistance;	border_MinZ = kHugeDistance;	border_MaxZ = -kHugeDistance;	for(i = 0; i < theTerrain.seaCount; ++i) {		if(theTerrain.seaList[i]->boundingBox[0].x < border_MinX)		border_MinX = theTerrain.seaList[i]->boundingBox[0].x;		if(theTerrain.seaList[i]->boundingBox[1].x > border_MaxX)		border_MaxX = theTerrain.seaList[i]->boundingBox[1].x;		if(theTerrain.seaList[i]->boundingBox[0].z < border_MinZ)		border_MinZ = theTerrain.seaList[i]->boundingBox[0].z;		if(theTerrain.seaList[i]->boundingBox[2].z > border_MaxZ)		border_MaxZ = theTerrain.seaList[i]->boundingBox[2].z;	}	border_MinX += kTerrainFrontierWidth;	border_MaxX -= kTerrainFrontierWidth;	border_MinZ += kTerrainFrontierWidth;	border_MaxX -= kTerrainFrontierWidth;		//Build collision map	theError = World_BuildCollisionMap(&theTerrain);	if(theError) {		Terrain_Dispose();		InfinityRendering_DisposeContext(state);		return theError;	}		//Clear ship list	shipCount = 0;		return noErr;}static void Ship_Prepare(ExtendedShipPtr ship){	ObjectPtr			object = &ship->megaObject.object;	long				i;		//Look for special shapes	ship->headShape = Shape_GetPtrFromID(object, kShapeID_PilotHead);	ship->bodyShape = Shape_GetPtrFromID(object, kShapeID_PilotBody);	ship->rudderShape_1 = Shape_GetPtrFromID(object, kShapeID_Rudder_1);	ship->rudderShape_2 = Shape_GetPtrFromID(object, kShapeID_Rudder_2);	ship->propellerShape_1 = Shape_GetPtrFromID(object, kShapeID_Propeller_1);	ship->propellerShape_2 = Shape_GetPtrFromID(object, kShapeID_Propeller_2);	ship->propellerShape_3 = Shape_GetPtrFromID(object, kShapeID_Propeller_3);	ship->propellerShape_4 = Shape_GetPtrFromID(object, kShapeID_Propeller_4);	ship->flameShape_1 = Shape_GetPtrFromID(object, kShapeID_TurboFlame_1);	ship->flameShape_2 = Shape_GetPtrFromID(object, kShapeID_TurboFlame_2);		//Attach scripts	ship->autoRun = Script_GetPtrFromID(&ship->megaObject, kScriptID_Autorun);	ship->turbo = Script_GetPtrFromID(&ship->megaObject, kScriptID_Turbo);	ship->reverseTurbo = Script_GetPtrFromID(&ship->megaObject, kScriptID_TurboReverse);	ship->currentScript = nil;		//Make sure we have a turbo & turbo reverse scripts	if((ship->turbo == nil) || (ship->reverseTurbo == nil)) {		ship->turbo = nil;		ship->reverseTurbo = nil;	}		//Clear wake	for(i = 0; i < kWakeNumSprites; ++i) {		Vector_Clear(&ship->wakePositions[i]);		Vector_Clear(&ship->wakeDirections[i]);		ship->wakeTime[i] = 0;	}	Vector_Clear(&ship->wakeLastPosition);		//Set terrain collision params	ship->radius = object->boundingBox[1].x;	ship->center1 = object->boundingBox[2].z - ship->radius;	ship->center2 = object->boundingBox[0].z + ship->radius;		//Setup other params	ship->turboState = false;	ship->turboFlame = false;	ship->turboStartTime = 0;	ship->nextDoor = 1;	ship->lastCheckPoint = 0;	ship->nextCheckPoint = theRace->doorList[0].nextCheckPoint;	ship->checkPointTime = 0;	ship->inCheckPoint = false;	#if __RENDER_SHIP_COLLISION_NORMAL__	Vector_Clear(&ship->normal);#endif}OSErr World_InstallShip(FSSpec* shipFile, PlayerConfigurationPtr pilotConfig, VectorPtr position, float rotateY){	ExtendedShipPtr			ship;	MetaFile_ReferencePtr	reference;	OSErr					theError;	OSType					dataType,							dataID;	TextureSetPtr			textureSet;		if(shipCount == kMaxPlayers)	return kError_MaxItems;		ship = &shipList[shipCount];		//Open MetaFile	theError = MetaFile_Read_OpenFile(shipFile, &reference);	if(theError)	return theError;		//Load model	theError = MetaFile_Read_MegaObject_ByIndex(reference, &ship->megaObject, 1, kMetaFile_SkipNone);	if(theError)	return theError;		//Load default texture set	if(pilotConfig->shipTextureID == kNoID)	theError = MetaFile_Read_TextureSet_ByIndex(reference, &textureSet, ship->megaObject.object.id, 1);	else {		theError = MetaFile_Read_TextureSet_ByID(reference, &textureSet, ship->megaObject.object.id, pilotConfig->shipTextureID);		if(theError == kError_ItemNotFound)		theError = MetaFile_Read_TextureSet_ByIndex(reference, &textureSet, ship->megaObject.object.id, 1);	}	if(theError)	return theError;		//Extract physic params	dataType = kSubTag_ShipPhysicParameters;	theError = MetaFile_Read_Data(reference, &dataType, 1, (Ptr*) &ship->params, &dataID);	if(theError)	return theError;						//Extract engine sound	dataType = kSubTag_Sound;	dataID = kSoundID_Engine;	theError = MetaFile_Read_Data(reference, &dataType, kMetaFile_UseID, (Ptr*) &ship->engineSound, &dataID);	if(theError)	return theError;		//Extract turbo sound	dataType = kSubTag_Sound;	dataID = kSoundID_Turbo;	theError = MetaFile_Read_Data(reference, &dataType, kMetaFile_UseID, (Ptr*) &ship->turboSound, &dataID);	if(theError)	return theError;		//Close MetaFile	MetaFile_Read_CloseFile(reference);		//Load texture in VRAM	theError = VRAM_LoadTextureSet(&videoMemory, textureSet, thePrefs.textureFlags);	if(theError)	return theError;	MegaObject_AttachTextureSet(&ship->megaObject, textureSet);	TextureSet_Dispose(textureSet);		//Resolve	MegaObject_Resolve(&ship->megaObject, &videoMemory);		//Setup ExtendedShip structure	ship->player = pilotConfig;	Ship_Prepare(ship);	ship->shipNum = shipCount;		//Prepare ship for collision dectection	MegaObject_CollisionAware(&ship->megaObject);		//Place ship	ship->megaObject.object.pos.w = *position;	ship->megaObject.object.scale = kShipScale;	ship->megaObject.object.rotateX = 0.0;	ship->megaObject.object.rotateY = rotateY;	ship->megaObject.object.rotateZ = 0.0;	Object_UpdateMatrix(&ship->megaObject.object);		//Set network data#if !__DEMO_MODE__	networkShipBuffers[shipCount].position = *position;	Quaternion_MatrixToQuaternion(&ship->megaObject.object.pos, &networkShipBuffers[shipCount].orientation);#endif		//Prepare physic engine	Physic_InitShip(ship); // must be called with all initial positional parameters set		//Update player config	pilotConfig->playerShip = ship;		//Done!	++shipCount;		return noErr;}static void Audio_InstallModelReference(ModelReferencePtr reference){	InfinityAudio_InstallObject(kCreatorType, (ObjectPtr) reference->id, &reference->pos);}static void Audio_InstallSource(SourcePtr source){	AmbientSoundPtr		sound = (AmbientSoundPtr) source->soundID;		if(sound->flags & kFlag_RandomPlay)	InfinityAudio_InstallSound_AmbientRandom(kCreatorType, &sound->soundHeader, nil, &source->position, source->minDistance, source->maxDistance, source->volume, source->pitch, sound->minTime, sound->maxTime, nil);	else	InfinityAudio_InstallSound_AmbientLoop(kCreatorType, &sound->soundHeader, nil, &source->position, source->minDistance, source->maxDistance, source->volume, source->pitch, nil);}static void Audio_InstallAnimation(ModelAnimationPtr anim){	if(anim->modelID == kFlyThroughID)	return;		InfinityAudio_InstallObject(kCreatorType, (ObjectPtr) anim->modelID, &anim->pos);}static void Audio_InstallEverywhere(AmbientSoundPtr sound){	if(sound->flags & kFlag_RandomPlay)	InfinityAudio_InstallSound_Random(kCreatorType, &sound->soundHeader, sound->volume, sound->panoramic, sound->pitch, sound->minTime, sound->maxTime, nil);	else	InfinityAudio_InstallSound_Loop(kCreatorType, &sound->soundHeader, sound->volume, sound->panoramic, sound->pitch, nil);}void World_InstallAudio(){	long				i,						j;		//Create audio environnement	InfinityAudio_CleanUp(kCreatorType);		for(i = 0; i < theTerrain.sourceCount; ++i)	if(theTerrain.sourceList[i].sourceType == kSource_Sound)	Audio_InstallSource(&theTerrain.sourceList[i]);		for(i = 0; i < theTerrain.meshCount; ++i)	for(j = 0; j < theTerrain.meshList[i]->referenceCount; ++j)	Audio_InstallModelReference(&theTerrain.meshList[i]->referenceList[j]);		for(i = 0; i < theTerrain.seaCount; ++i)	for(j = 0; j < theTerrain.seaList[i]->referenceCount; ++j)	Audio_InstallModelReference(&theTerrain.seaList[i]->referenceList[j]);		for(i = 0; i < theTerrain.animCount; ++i)	Audio_InstallAnimation(theTerrain.animList[i]);		for(i = 0; i < theTerrain.soundCount; ++i)	if(theTerrain.soundList[i]->flags & kFlag_Everywhere)	Audio_InstallEverywhere(theTerrain.soundList[i]);		for(i = 0; i < shipCount; ++i)	InfinityAudio_InstallSound_AmbientLoop(kCreatorType, shipList[i].engineSound, nil, &shipList[i].megaObject.object.pos.w, kMinEngineDistance, kMaxEngineDistance, 0.0 /*shipList[i].params->power_SoundVolume*/, shipList[i].params->power_MinSoundPitchRatio, &shipList[i].engineSoundRef);}void World_Prepare(){	long				i,						j;		//Get frame time	worldState->frameTime = RClock_GetTime();		//Prepare ships	for(i = 0; i < shipCount; ++i) {		shipList[i].dynamics.upsideDownTime	= worldState->frameTime;		shipList[i].dynamics.underWaterTime	= worldState->frameTime;	}		//Start scripts	Anim_Start(&theTerrain, worldState->frameTime);	for(i = 0; i < modelCount; ++i) {		if(modelList[i].megaObject.scriptCount) {			modelList[i].hasScripts = true;			modelList[i].lastScriptUpdateTime = worldState->frameTime;			for(j = 0; j < modelList[i].megaObject.scriptCount; ++j) {				Script_Stop(modelList[i].megaObject.scriptList[j]);				Script_Start(modelList[i].megaObject.scriptList[j], worldState->frameTime);			}		}		else		modelList[i].hasScripts = false;	}		//Update sea	for(i = 0; i < theTerrain.seaCount; ++i)	theTerrain.seaList[i]->lastUpdateTime = worldState->frameTime;}void World_Unload(){	long				i,						j;							//Stop sound	InfinityAudio_CleanUp(kCreatorType);		//Stop scripts	Anim_Stop();	for(i = 0; i < modelCount; ++i)	for(j = 0; j < modelList[i].megaObject.scriptCount; ++j)	Script_Stop(modelList[i].megaObject.scriptList[j]);		//Clean up	Terrain_Dispose();	for(i = 0; i < shipCount; ++i) {		MegaObject_ReleaseData(&shipList[i].megaObject);		DisposePtr((Ptr) shipList[i].params);		DisposePtr((Ptr) shipList[i].engineSound);		DisposePtr((Ptr) shipList[i].turboSound);	}	shipCount = 0;	#if __RENDER_CHECK_POINTS__	Shape_Dispose(checkPoint_left);	Shape_Dispose(checkPoint_middle);	Shape_Dispose(checkPoint_right);	Shape_Dispose(start_left);	Shape_Dispose(start_middle);	Shape_Dispose(start_right);#endif	//Dispose required FX	PostFX_Text_Quit(worldState);	if(turboTexture != nil) {		QATextureDelete(worldState->engine, turboTexture);		turboTexture = nil;	}	if(jokerTexture != nil) {		QATextureDelete(worldState->engine, jokerTexture);		jokerTexture = nil;	}	if(thePrefs.engineFlags & kPref_EngineFlagVideoFX) {		if(theTerrain.skyFlags & kSkyFlag_RenderRain)		PostFX_Rain_Quit(worldState);		if(theTerrain.skyFlags & kSkyFlag_RenderSnow)		PostFX_Snow_Quit(worldState);		if(theTerrain.skyFlags & kSkyFlag_RenderMoon)		PostFX_Moon_Quit(worldState);		if(theTerrain.skyFlags & kSkyFlag_RenderLF)		PostFX_LensFlare_Quit(worldState);				if(wakeTexture != nil)		QATextureDelete(worldState->engine, wakeTexture);	}		InfinityRendering_DisposeContext(worldState);		if(collisionMap != nil)	DisposePtr((Ptr) collisionMap);	collisionMap = nil;}void World_UpdateSea(){	long				i,						j;	long				timeOffset;	float				uMove,						vMove,						amplitude,						scaleX,						scaleZ;	float				time;	Boolean				colorize;	float				f1,						f2;							amplitude = theTerrain.waveAmplitude;	scaleX = theTerrain.waveScaleX;	scaleZ = theTerrain.waveScaleZ;	colorize = (theTerrain.flags & kFlag_Colorize) >> 16;		time = (float) worldState->frameTime / theTerrain.timeScale;	timeOffset = worldState->frameTime - theTerrain.seaList[0]->lastUpdateTime;	theTerrain.seaList[0]->lastUpdateTime = worldState->frameTime;	uMove = timeOffset * theTerrain.seaMoveU;	vMove = timeOffset * theTerrain.seaMoveV;		f1 = 2.0 * DegreesToRadians(worldState->frameTime);	f2 = 3.0 / 2.0 * f1;			for(i = 0; i < theTerrain.seaCount; ++i) {		char				*vu, *vv;		char				*vx, *vz;		SeaMeshPtr			mesh;			mesh = theTerrain.seaList[i];		vu = (char*) &mesh->pointList[0].u;		vv = (char*) &mesh->pointList[0].v;		vx = (char*) &mesh->pointList[0].point.x;		vz = (char*) &mesh->pointList[0].point.z;				for(j = 0; j < mesh->pointCount; ++j, vu += sizeof(Vertex), vv += sizeof(Vertex), vx += sizeof(Vertex), vz += sizeof(Vertex)) {			*((float*) vu) += uMove + TCos(*((float*) vz) + f1) / 2000.0;			*((float*) vv) += vMove + TSin(*((float*) vx) + f2) / 2000.0;		}				if(colorize) {			char				*kr, *kg;			char				*vy;						vy = (char*) &mesh->pointList[0].point.y;			kr = (char*) &mesh->lightningList[0].kd_r;			kg = (char*) &mesh->lightningList[0].kd_g;			for(j = 0; j < mesh->pointCount; ++j, vy += sizeof(Vertex), kr += sizeof(Lightning), kg += sizeof(Lightning)) {				*((float*) kr) = *((float*) kg) = (*((float*) vy) + amplitude) / 2.0 + (1.0 - amplitude);				//light->kd_r += TableCos(vertexPtr->point.y + 2 * DegreesToRadians(Clock_GetTime())) / 100.0;				//light->kd_g += TableSin(vertexPtr->point.x + 3 * DegreesToRadians(Clock_GetTime())) / 100.0;			}		}	}}